// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel FindAdjacentTriangles
#pragma kernel DiscoverMesh
#pragma kernel FindClosestTriangle
#pragma kernel UpdateMesh

struct Vertex
{
    float3 pos;
    float3 nor;
    float4 tang;
    float uvx;
    float uvy;
};

struct AdjacentTriangles
{
    int tri1TriangleIndex;
    int tri2TriangleIndex;
    int tri3TriangleIndex;
    int hasTriangleBeenVisited;
};
struct TriangleInProximity
{
    uint id;
    float dist;
};

RWStructuredBuffer<Vertex> gpuVertices;
StructuredBuffer<int> gpuIndices;
RWStructuredBuffer<AdjacentTriangles> gpuAdjacentTriangle;
StructuredBuffer<int> gpuTrianglesShouldCheck;
AppendStructuredBuffer<int> gpuTrianglesShouldCheckAppend;
RWStructuredBuffer<int> gpuAmountTrianglesToCheck;
RWStructuredBuffer<int> debug;

RWStructuredBuffer<int> gpuAmountTrianglesInProximity;
AppendStructuredBuffer<TriangleInProximity> gpuTrianglesInProximity;

float currentTime;
float distThreshold;
int amountTriangles;
int amountTrianglesToCheck;
int amountTrianglesToColor;
int amountVerts;
float decaySpeed;
float3 hitPos;

bool EqualVector3(float3 a, float3 b)
{
    float dist = distance(a, b);
    if(dist < 0.5)
    {
        return true;
    }
    return false;
}

bool EqualVector3(float3 a[3], float3 b)
{
    float minDist = 0.00001;
    
    if(abs(a[0].x - b.x) < minDist && abs(a[0].y - b.y) < minDist && abs(a[0].z - b.z) < minDist)
    {
        return true;
    }
    if(abs(a[1].x - b.x) < minDist && abs(a[1].y - b.y) < minDist && abs(a[1].z - b.z) < minDist)
    {
        return true;
    }
    if(abs(a[2].x - b.x) < minDist && abs(a[2].y - b.y) < minDist && abs(a[2].z - b.z) < minDist)
    {
        return true;
    }
    return false;
}

[numthreads(128,1,1)]
void FindAdjacentTriangles (uint3 id : SV_DispatchThreadID)
{
    if(id.x > (uint)amountTriangles)
    {
        return;
    }
    uint index1 = gpuIndices[id.x * 3];
    uint index2 = gpuIndices[id.x * 3 + 1];
    uint index3 = gpuIndices[id.x * 3 + 2];
    
    float3 vertex1 = gpuVertices[index1].pos;
    float3 vertex2 = gpuVertices[index2].pos;
    float3 vertex3 = gpuVertices[index3].pos;
    
    float3 allPos[3];
    allPos[0] = vertex1;
    allPos[1] = vertex2;
    allPos[2] = vertex3;

    float3 newVertex1;
    float3 newVertex2;
    float3 newVertex3;

    uint newIndex1;
    uint newIndex2;
    uint newIndex3;

    int adjacentTrianglesFound[3] = {-1, -1, -1};
    int amountTrianglesFound = 0;

    for (int i = 0; i < amountTriangles; i++)
    {
        newIndex1 = gpuIndices[i * 3];
        newIndex2 = gpuIndices[i * 3 + 1];
        newIndex3 = gpuIndices[i * 3 + 2];

        if((uint)i == id.x)
        {
            continue;
        }

        newVertex1 = gpuVertices[newIndex1].pos;
        newVertex2 = gpuVertices[newIndex2].pos;
        newVertex3 = gpuVertices[newIndex3].pos;
        
        int amountMatchingVertexFound = 0;
        if(EqualVector3(allPos, newVertex1))
        {
            amountMatchingVertexFound++;
        }
        if(EqualVector3(allPos, newVertex2))
        {
            amountMatchingVertexFound++;
        }
        if(EqualVector3(allPos, newVertex3))
        {
            amountMatchingVertexFound++;
        }

        if(amountMatchingVertexFound >= 2)
        {
            adjacentTrianglesFound[amountTrianglesFound] = i;
            amountTrianglesFound++;
        }
    }

    gpuAdjacentTriangle[id.x].tri1TriangleIndex = adjacentTrianglesFound[0];
    gpuAdjacentTriangle[id.x].tri2TriangleIndex = adjacentTrianglesFound[1];
    gpuAdjacentTriangle[id.x].tri3TriangleIndex = adjacentTrianglesFound[2];
    gpuAdjacentTriangle[id.x].hasTriangleBeenVisited = 0;
}

void RemoveConnectingTriangleAdjaceny(int indexTriangleToCheck, int adjacentTrianlge1, int adjacentTrianlge2, int adjacentTrianlge3)
{
    if(gpuAdjacentTriangle[adjacentTrianlge1].tri1TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge1].tri1TriangleIndex = -1;
    if(gpuAdjacentTriangle[adjacentTrianlge1].tri2TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge1].tri2TriangleIndex = -1;
    if(gpuAdjacentTriangle[adjacentTrianlge1].tri3TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge1].tri3TriangleIndex = -1;


    if(gpuAdjacentTriangle[adjacentTrianlge2].tri1TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge2].tri1TriangleIndex = -1;
    if(gpuAdjacentTriangle[adjacentTrianlge2].tri2TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge2].tri2TriangleIndex = -1;
    if(gpuAdjacentTriangle[adjacentTrianlge2].tri3TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge2].tri3TriangleIndex = -1;


    if(gpuAdjacentTriangle[adjacentTrianlge3].tri1TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge3].tri1TriangleIndex = -1;
    if(gpuAdjacentTriangle[adjacentTrianlge3].tri2TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge3].tri2TriangleIndex = -1;
    if(gpuAdjacentTriangle[adjacentTrianlge3].tri3TriangleIndex == indexTriangleToCheck)
        gpuAdjacentTriangle[adjacentTrianlge3].tri3TriangleIndex = -1;
}

[numthreads(128,1,1)]
void DiscoverMesh (uint3 id : SV_DispatchThreadID)
{
    if(id.x >= (uint)amountTrianglesToCheck)
    {
        return;
    }

    int index1 = gpuIndices[gpuTrianglesShouldCheck[id.x] * 3];
    int index2 = gpuIndices[gpuTrianglesShouldCheck[id.x] * 3 + 1];
    int index3 = gpuIndices[gpuTrianglesShouldCheck[id.x] * 3 + 2];

    int adjacentTrianlge1 = gpuAdjacentTriangle[gpuTrianglesShouldCheck[id.x]].tri1TriangleIndex;
    int adjacentTrianlge2 = gpuAdjacentTriangle[gpuTrianglesShouldCheck[id.x]].tri2TriangleIndex;
    int adjacentTrianlge3 = gpuAdjacentTriangle[gpuTrianglesShouldCheck[id.x]].tri3TriangleIndex;

    gpuAdjacentTriangle[gpuTrianglesShouldCheck[id.x]].hasTriangleBeenVisited = -1;

    RemoveConnectingTriangleAdjaceny(gpuTrianglesShouldCheck[id.x], adjacentTrianlge1, adjacentTrianlge2, adjacentTrianlge3);

    if(gpuVertices[index1].uvx == 0) { gpuVertices[index1].uvx = 1; }
    if(gpuVertices[index2].uvx == 0) { gpuVertices[index2].uvx = 1; }
    if(gpuVertices[index3].uvx == 0) { gpuVertices[index3].uvx = 1; }
    
    if(adjacentTrianlge1 > 0 && gpuAdjacentTriangle[adjacentTrianlge1].hasTriangleBeenVisited == 0)
    {
        gpuTrianglesShouldCheckAppend.Append(adjacentTrianlge1);
        InterlockedAdd(gpuAmountTrianglesToCheck[0], 1);
    }
    if(adjacentTrianlge2 > 0 && gpuAdjacentTriangle[adjacentTrianlge2].hasTriangleBeenVisited == 0)
    {
        gpuTrianglesShouldCheckAppend.Append(adjacentTrianlge2);
        InterlockedAdd(gpuAmountTrianglesToCheck[0], 1);
    }
    if(adjacentTrianlge3 > 0 && gpuAdjacentTriangle[adjacentTrianlge3].hasTriangleBeenVisited == 0)
    {
        gpuTrianglesShouldCheckAppend.Append(adjacentTrianlge3);
        InterlockedAdd(gpuAmountTrianglesToCheck[0], 1);
    }
}

[numthreads(128,1,1)]
void FindClosestTriangle (uint3 id : SV_DispatchThreadID)
{
    if(id.x > (uint)amountTriangles)
    {
        return;
    }
    uint index1 = gpuIndices[id.x * 3];
    uint index2 = gpuIndices[id.x * 3 + 1];
    uint index3 = gpuIndices[id.x * 3 + 2];
    
    float3 vertex1 = gpuVertices[index1].pos;
    float3 vertex2 = gpuVertices[index2].pos;
    float3 vertex3 = gpuVertices[index3].pos;
    
    float3 avgPos = (vertex1 + vertex2 + vertex3) / 3;
    float dist = distance(avgPos, hitPos);
    
    if(dist < distThreshold)
    {
        InterlockedAdd(gpuAmountTrianglesInProximity[0], 1);
        TriangleInProximity tri;
        tri.id = id.x;
        tri.dist = dist;
        gpuTrianglesInProximity.Append(tri);
    }
}

[numthreads(128,1,1)]
void UpdateMesh (uint3 id : SV_DispatchThreadID)
{
    if(id.x > (uint)amountVerts)
    {
        return;
    }
    float uvx = gpuVertices[id.x].uvx;

    if(uvx > 0)
    {
        uvx -= decaySpeed;
        uvx = uvx < 0 ? 0 : uvx;
        gpuVertices[id.x].uvx = uvx;
    }
}
