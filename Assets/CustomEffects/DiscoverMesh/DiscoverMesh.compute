// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel DiscoverMesh

struct Vertex
{
    float3 pos;
    float3 nor;
    float4 tang;
    float2 uv;
};

struct CheckedVertex
{
    uint index;
    float3 pos;
};

RWStructuredBuffer<Vertex> gpuVertices;
StructuredBuffer<uint> gpuIndices;
AppendStructuredBuffer<uint> gpuAdjacentTriangle;
RWStructuredBuffer<uint> gpuCheckedIndices;
RWStructuredBuffer<uint> gpuAdjacentTrianglesCounter;
AppendStructuredBuffer<uint> debug;

uint amountIndicesToCheck;

bool EqualVector3(float3 a, float3 b)
{
    float dist = distance(a, b);
    if(dist < 0.5)
    {
        return true;
    }
    return false;
}

bool EqualVector3(float3 a[3], float3 b)
{
    float minDist = 0.000001;
    
    if(abs(a[0].x - b.x) < minDist && abs(a[0].y - b.y) < minDist)
    {
        return true;
    }
    if(abs(a[1].x - b.x) < minDist && abs(a[1].y - b.y) < minDist)
    {
        return true;
    }
    if(abs(a[2].x - b.x) < minDist && abs(a[2].y - b.y) < minDist)
    {
        return true;
    }
    return false;
}

[numthreads(32,1,1)]
void DiscoverMesh (uint3 id : SV_DispatchThreadID)
{
    uint i1 = gpuIndices[id.x * 3];
    uint i2 = gpuIndices[id.x * 3 + 1];
    uint i3 = gpuIndices[id.x * 3 + 2];
    
    float3 v1 = gpuVertices[i1].pos;
    float3 v2 = gpuVertices[i2].pos;
    float3 v3 = gpuVertices[i3].pos;

    uint amountCheckedIndices;
    uint checkedIndicesStride;
    gpuCheckedIndices.GetDimensions(amountCheckedIndices, checkedIndicesStride);
    
    int amountIndexSame = 0;
    for (int i = 0; i < amountCheckedIndices; i++)
    {
        if(i1 == gpuCheckedIndices[i] || i2 == gpuCheckedIndices[i] || i3 == gpuCheckedIndices[i])
        {
            amountIndexSame++;
        }
    }
    if(amountIndexSame == 3 || i1 == 0 && i2 == 0 && i3 == 0)
    {
        return;
    }

    float3 allPos[3];
    allPos[0] = v1;
    allPos[1] = v2;
    allPos[2] = v3;

    float3 vCheck;
    int amountVertexMatch = 0;

    uint indexFound1 = 0;
    uint indexFound2 = 0;
    uint indexFound3 = 0;

    for (int j = 0; j < amountCheckedIndices; j++)
    {
        vCheck = gpuVertices[gpuCheckedIndices[j]].pos;
        
        if(EqualVector3(allPos, vCheck))
        {
            if(indexFound1 == 0)
            {
                debug.Append(gpuCheckedIndices[j]);
                indexFound1 = gpuCheckedIndices[j];
            }
            else if(indexFound2 == 0)
            {
                debug.Append(gpuCheckedIndices[j]);
                indexFound2 = gpuCheckedIndices[j];
            }
            else
            {
                debug.Append(gpuCheckedIndices[j]);
                indexFound3 = gpuCheckedIndices[j];
            }
            amountVertexMatch++;
        }
    }
    
    if(amountVertexMatch >= 1)
    {
        //InterlockedAdd(gpuAdjacentTrianglesCounter[0], 3);

        if(!(i1 == indexFound1 || i1 == indexFound2 || i1 == indexFound3))
        {
            InterlockedAdd(gpuAdjacentTrianglesCounter[0], 1);
            gpuAdjacentTriangle.Append(i1);
        }
        if(!(i2 == indexFound1 || i2 == indexFound2 || i2 == indexFound3))
        {
            InterlockedAdd(gpuAdjacentTrianglesCounter[0], 1);
            gpuAdjacentTriangle.Append(i2);
        }
        if(!(i3 == indexFound1 || i3 == indexFound2 || i3 == indexFound3))
        {
            InterlockedAdd(gpuAdjacentTrianglesCounter[0], 1);
            gpuAdjacentTriangle.Append(i3);
        }
        // gpuAdjacentTriangle.Append(i1);
        // gpuAdjacentTriangle.Append(i2);
        // gpuAdjacentTriangle.Append(i3);

        gpuVertices[i1].uv = float2(1,1);
        gpuVertices[i2].uv = float2(1,1);
        gpuVertices[i3].uv = float2(1,1);
    }
}
