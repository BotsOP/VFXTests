// Each #kernel tells which function to compile; you can have many kernels
#pragma kernel SkinnedToMesh
#pragma kernel triangleDestructionTarget
#pragma kernel triangleDestruction

int SKINNED_VERTEX_STRIDE = 40;
int VERTEX_STRIDE = 48;

RWByteAddressBuffer bufSkinnedVertices;
RWByteAddressBuffer bufVertices;
RWByteAddressBuffer bufIndices;

float triDist;
float triLerp;
float time;
float deltaTime;
bool spawn;
bool reset;
float3 target;
float4x4 objToWorld;
float4x4 worldToObj;

float3 hash33(float3 p3)
{
    p3 = frac(p3 * float3(.1031, .1030, .0973));
    p3 += dot(p3, p3.yxz+33.33);
    return frac((p3.xxy + p3.yxx)*p3.zyx);
}

[numthreads(64,1,1)]
void SkinnedToMesh (uint3 id : SV_DispatchThreadID)
{
    SKINNED_VERTEX_STRIDE = 40;
    VERTEX_STRIDE = 56;
    
    int index1 = bufIndices.Load((id.x * 3) * 4);
    int index2 = bufIndices.Load((id.x * 3 + 1) * 4);
    int index3 = bufIndices.Load((id.x * 3 + 2) * 4);
    
    float3 animTri1 = asfloat(bufSkinnedVertices.Load3(index1 * SKINNED_VERTEX_STRIDE));
    float3 animTri2 = asfloat(bufSkinnedVertices.Load3(index2 * SKINNED_VERTEX_STRIDE));
    float3 animTri3 = asfloat(bufSkinnedVertices.Load3(index3 * SKINNED_VERTEX_STRIDE));
    
    bufVertices.Store3(index1 * VERTEX_STRIDE, asuint(animTri1));
    bufVertices.Store3(index2 * VERTEX_STRIDE, asuint(animTri2));
    bufVertices.Store3(index3 * VERTEX_STRIDE, asuint(animTri3));

    // bufVertices.Store(index1 * VERTEX_STRIDE + 40, asuint(0));
    // bufVertices.Store(index2 * VERTEX_STRIDE + 40, asuint(0));
    // bufVertices.Store(index3 * VERTEX_STRIDE + 40, asuint(0));

    // bufVertices.Store3(index1 * VERTEX_STRIDE + 44, asuint(float3(0, 0, 0)));
    // bufVertices.Store3(index2 * VERTEX_STRIDE + 44, asuint(float3(0, 0, 0)));
    // bufVertices.Store3(index3 * VERTEX_STRIDE + 44, asuint(float3(0, 0, 0)));
}

[numthreads(64,1,1)]
void triangleDestructionTarget (uint3 id : SV_DispatchThreadID)
{
    SKINNED_VERTEX_STRIDE = 40;
    VERTEX_STRIDE = 56;
    
    int index1 = bufIndices.Load((id.x * 3) * 4);
    int index2 = bufIndices.Load((id.x * 3 + 1) * 4);
    int index3 = bufIndices.Load((id.x * 3 + 2) * 4);
    
    float3 tri1 = asfloat(bufSkinnedVertices.Load3(index1 * SKINNED_VERTEX_STRIDE));
    float3 tri2 = asfloat(bufSkinnedVertices.Load3(index2 * SKINNED_VERTEX_STRIDE));
    float3 tri3 = asfloat(bufSkinnedVertices.Load3(index3 * SKINNED_VERTEX_STRIDE));

    float3 animCenterTri = (tri1 + tri2 + tri3) / 3;

    float distanceToTarget = distance(animCenterTri, target);
    if(distanceToTarget < triDist)
    {
        float distT = distanceToTarget * (1 / triDist);
        distT = 1 - distT;

        float3 nor1 = asfloat(bufSkinnedVertices.Load3(index1 * SKINNED_VERTEX_STRIDE + 12));
        float3 nor2 = asfloat(bufSkinnedVertices.Load3(index2 * SKINNED_VERTEX_STRIDE + 12));
        float3 nor3 = asfloat(bufSkinnedVertices.Load3(index3 * SKINNED_VERTEX_STRIDE + 12));

        float3 avgNor = (nor1 + nor2 + nor3) / 3;

        bufVertices.Store3(index1 * VERTEX_STRIDE + 44, asuint(animCenterTri + avgNor * distT));

        bufVertices.Store(index1 * VERTEX_STRIDE + 40, asuint(triLerp));
        bufVertices.Store(index2 * VERTEX_STRIDE + 40, asuint(triLerp));
        bufVertices.Store(index3 * VERTEX_STRIDE + 40, asuint(triLerp));
    }
}

[numthreads(64,1,1)]
void triangleDestruction (uint3 id : SV_DispatchThreadID)
{
    SKINNED_VERTEX_STRIDE = 40;
    VERTEX_STRIDE = 56;
    
    int index1 = bufIndices.Load((id.x * 3) * 4);
    int index2 = bufIndices.Load((id.x * 3 + 1) * 4);
    int index3 = bufIndices.Load((id.x * 3 + 2) * 4);
    
    float3 tri1 = asfloat(bufVertices.Load3(index1 * VERTEX_STRIDE));
    float3 tri2 = asfloat(bufVertices.Load3(index2 * VERTEX_STRIDE));
    float3 tri3 = asfloat(bufVertices.Load3(index3 * VERTEX_STRIDE));

    float3 animCenterTri = (tri1 + tri2 + tri3) / 3;

    float3 newTarget = asfloat(bufVertices.Load3(index1 * VERTEX_STRIDE + 44));
    float affected = bufVertices.Load(index1 * VERTEX_STRIDE + 40);

    float distanceToTarget = distance(animCenterTri, newTarget);
    if(affected > 0)
    {
        float3 animTri1 = asfloat(bufVertices.Load3(index1 * VERTEX_STRIDE));
        float3 animTri2 = asfloat(bufVertices.Load3(index2 * VERTEX_STRIDE));
        float3 animTri3 = asfloat(bufVertices.Load3(index3 * VERTEX_STRIDE));

        float3 tri1Offset = animTri1 - animCenterTri;
        float3 tri2Offset = animTri2 - animCenterTri;
        float3 tri3Offset = animTri3 - animCenterTri;
        
        float3 newCenterTri = lerp(animCenterTri, newTarget, triLerp);
        tri1 = newCenterTri + tri1Offset;
        tri2 = newCenterTri + tri2Offset;
        tri3 = newCenterTri + tri3Offset;

        bufVertices.Store(index1 * VERTEX_STRIDE + 40, asuint(triLerp));
        bufVertices.Store(index2 * VERTEX_STRIDE + 40, asuint(triLerp));
        bufVertices.Store(index3 * VERTEX_STRIDE + 40, asuint(triLerp));
    }

    bufVertices.Store3(index1 * VERTEX_STRIDE, asuint(tri1));
    bufVertices.Store3(index2 * VERTEX_STRIDE, asuint(tri2));
    bufVertices.Store3(index3 * VERTEX_STRIDE, asuint(tri3));
}


// [numthreads(64,1,1)]
// void TopDownDestroy (uint3 id : SV_DispatchThreadID)
// {
//     VERTEX_STRIDE = 48;
//     
//     int index1 = bufIndices.Load((id.x * 3) * 4);
//     int index2 = bufIndices.Load((id.x * 3 + 1) * 4);
//     int index3 = bufIndices.Load((id.x * 3 + 2) * 4);
//     
//     float3 animTri1 = asfloat(bufSkinnedVertices.Load3(index1 * 40));
//     float3 animTri2 = asfloat(bufSkinnedVertices.Load3(index2 * 40));
//     float3 animTri3 = asfloat(bufSkinnedVertices.Load3(index3 * 40));
//
//     float3 animCenterTri = (animTri1 + animTri2 + animTri3) / 3;
//
//     float triLerp4 = triLerp * 4;
//     float newLerp = animCenterTri.y - 1 + triLerp4;
//     newLerp = saturate(newLerp);
//     
//     float3 randPos = normalize(float3(0.5, 0.5, 0.5) - hash33(float3(index1, index2, index3)));
//     randPos = float3(randPos.x, 0, randPos.z) * triDist;
//     randPos += float3(0, 2, 0);
//
//     //float3 centerTri = (tri1 + tri2 +tri3) / 3;
//     
//     float3 newTri1 = lerp(animTri1, randPos + animTri1 - float3(0, animTri1.y, 0), newLerp);
//     float3 newTri2 = lerp(animTri2, randPos + animTri2 - float3(0, animTri2.y, 0), newLerp);
//     float3 newTri3 = lerp(animTri3, randPos + animTri3 - float3(0, animTri3.y, 0), newLerp);
//
//     if(reset)
//     {
//         bufVertices.Store3(index1 * VERTEX_STRIDE, asuint(animTri1));
//         bufVertices.Store3(index2 * VERTEX_STRIDE, asuint(animTri2));
//         bufVertices.Store3(index3 * VERTEX_STRIDE, asuint(animTri3));
//         return;
//     }
//     bufVertices.Store3(index1 * VERTEX_STRIDE, asuint(newTri1));
//     bufVertices.Store3(index2 * VERTEX_STRIDE, asuint(newTri2));
//     bufVertices.Store3(index3 * VERTEX_STRIDE, asuint(newTri3));
// }




